"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Vetch = void 0;
const node_fetch_1 = __importDefault(require("node-fetch"));
const querystring_1 = require("querystring");
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const vetchError_1 = require("./types/vetchError");
const responseTypes_1 = require("./enums/responseTypes");
const debug_1 = __importDefault(require("debug"));
const log = (0, debug_1.default)('vonage:vetch');
class Vetch {
    defaults;
    constructor(defaults) {
        this.defaults = defaults || { responseType: responseTypes_1.ResponseTypes.json };
        if (!this.defaults.responseType) {
            this.defaults.responseType = responseTypes_1.ResponseTypes.json;
        }
    }
    async _defaultAdapter(opts) {
        const { timeout } = opts;
        let timeoutId = null;
        const fetchConfig = opts;
        if (timeout) {
            const controller = new AbortController();
            timeoutId = setTimeout(() => controller.abort(), timeout);
            fetchConfig.signal = controller.signal;
        }
        try {
            const res = await (0, node_fetch_1.default)(opts.url, fetchConfig);
            const data = await this.getResponseData(opts, res);
            return this.createResponse(opts, res, data);
        }
        finally {
            clearTimeout(timeoutId);
        }
    }
    async request(opts = {}) {
        opts = this.validateOpts(opts);
        log('api request', opts);
        const formattedResponse = await this._defaultAdapter(opts);
        log('api response', formattedResponse);
        if (!opts.checkStatus(formattedResponse.status)) {
            const err = new vetchError_1.VetchError(`Request failed with status code ${formattedResponse.status}`, opts);
            err.code = String(formattedResponse.status);
            err.response = formattedResponse;
            throw err;
        }
        return formattedResponse;
    }
    async getResponseData(opts, res) {
        switch (opts.responseType) {
            case 'stream':
                return res.buffer();
            case 'json': {
                let data = await res.text();
                try {
                    data = JSON.parse(data);
                }
                catch {
                    // continue
                }
                return data;
            }
            default:
                return res.text();
        }
    }
    validateOpts(options) {
        const opts = (0, lodash_merge_1.default)({}, this.defaults, options);
        opts.headers = opts.headers || {};
        opts.checkStatus = this.checkStatus;
        if (!opts.url) {
            throw new Error('URL is required.');
        }
        const baseUrl = opts.baseUrl || opts.baseURL;
        if (baseUrl) {
            opts.url = baseUrl + opts.url;
        }
        if (opts.params) {
            let queryParams = (0, querystring_1.stringify)(opts.params);
            if (queryParams.startsWith('?')) {
                queryParams = queryParams.slice(1);
            }
            const prefix = opts.url.includes('?') ? '&' : '?';
            opts.url = `${opts.url}${prefix}${queryParams}`;
        }
        if (opts.data) {
            if (typeof opts.data === 'object') {
                opts.body = JSON.stringify(opts.data);
                opts.headers['Content-Type'] = 'application/json';
            }
            else {
                opts.body = opts.data;
            }
        }
        if (!opts.headers.Accept && opts.responseType === 'json') {
            opts.headers.Accept = 'application/json';
        }
        // Set our user agent
        opts.headers['user-agent'] = [
            `@vonage/server-sdk/3.0.0`,
            ` node/${process.version.replace('v', '')}`,
            opts.appendUserAgent ? ` ${opts.appendUserAgent}` : '',
        ].join('');
        // Allow a custom timeout to be used
        const httpAgent = new http_1.default.Agent({
            timeout: opts.timeout,
        });
        const httpsAgent = new https_1.default.Agent({
            timeout: opts.timeout,
        });
        opts.agent = (parsedUrl) => {
            if (parsedUrl.protocol === 'http:') {
                return httpAgent;
            }
            else {
                return httpsAgent;
            }
        };
        return opts;
    }
    checkStatus(status) {
        return status >= 200 && status < 300;
    }
    createResponse(opts, res, data) {
        const headers = {};
        res.headers.forEach((value, key) => {
            headers[key] = value;
        });
        return {
            config: opts,
            data: data,
            headers,
            status: res.status,
            statusText: res.statusText,
            request: {
                responseUrl: res.url,
            },
        };
    }
}
exports.Vetch = Vetch;
//# sourceMappingURL=vetch.js.map