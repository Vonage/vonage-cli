"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Record = void 0;
const enums_1 = require("../../enums");
class Record {
    action = enums_1.NCCOActions.RECORD;
    format;
    wrappedSplit;
    wrappedChannels;
    wrappedEndOnSilence;
    wrappedEndOnKey;
    wrappedTimeOut;
    beepStart;
    eventUrl;
    eventMethod;
    constructor(format, split, channels, endOnSilence, endOnKey, timeout, beepStart, eventUrl, eventMethod) {
        if (format) {
            this.format = format;
        }
        if (split) {
            this.split = split;
        }
        if (channels) {
            this.channels = channels;
        }
        if (endOnSilence) {
            this.endOnSilence = endOnSilence;
        }
        if (endOnKey) {
            this.endOnKey = endOnKey;
        }
        if (timeout) {
            this.timeout = timeout;
        }
        if (beepStart) {
            this.beepStart = beepStart;
        }
        if (eventUrl) {
            this.eventUrl = [eventUrl];
        }
        if (eventMethod) {
            this.eventMethod = eventMethod;
        }
    }
    get channels() {
        return this.wrappedChannels;
    }
    set channels(channels) {
        if (channels < 1 || channels > 32) {
            throw new Error('Channels must be between 1 and 32, inclusive');
        }
        if (this.wrappedSplit !== 'conversation') {
            throw new Error(`Channels must have split set to 'conversation' before changing channel numbers`);
        }
        this.wrappedChannels = channels;
    }
    get endOnKey() {
        return this.wrappedEndOnKey;
    }
    set endOnKey(character) {
        const re = /^[0-9*#]$/;
        if (!re.test(character)) {
            throw new Error('Valid characters are 0-9, *, and # only');
        }
        this.wrappedEndOnKey = character;
    }
    get endOnSilence() {
        return this.wrappedEndOnSilence;
    }
    set endOnSilence(numSeconds) {
        if (numSeconds < 3 || numSeconds > 10) {
            throw new Error('End on Silence must be between 3 and 10 seconds, inclusive');
        }
        this.wrappedEndOnSilence = numSeconds;
    }
    get split() {
        return 'conversation';
    }
    set split(splitType) {
        if (splitType !== 'conversation') {
            throw new Error("Recording can only be split to 'conversation'");
        }
        this.wrappedSplit = splitType;
    }
    get timeout() {
        return this.wrappedTimeOut;
    }
    set timeout(seconds) {
        if (seconds < 3 || seconds > 7200) {
            throw new Error('Recording timeout must be between 3 and 7200 seconds, inclusive');
        }
        this.wrappedTimeOut = seconds;
    }
    serializeToNCCO() {
        const data = {
            action: enums_1.NCCOActions.RECORD,
        };
        if (this.format) {
            data.format = this.format;
        }
        if (this.wrappedSplit) {
            data.split = this.split;
        }
        if (this.wrappedChannels) {
            data.channels = this.wrappedChannels;
        }
        if (this.wrappedEndOnKey) {
            data.endOnKey = this.endOnKey;
        }
        if (this.wrappedEndOnSilence) {
            data.endOnSilence = this.endOnSilence;
        }
        if (this.wrappedTimeOut) {
            data.timeOut = this.wrappedTimeOut;
        }
        if (this.beepStart) {
            data.beepStart = this.beepStart;
        }
        if (this.eventUrl) {
            data.eventUrl = this.eventUrl;
        }
        if (this.eventMethod) {
            data.eventMethod = this.eventMethod;
        }
        return data;
    }
}
exports.Record = Record;
//# sourceMappingURL=Record.js.map