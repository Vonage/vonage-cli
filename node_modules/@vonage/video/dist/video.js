"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Video = void 0;
const jwt_1 = require("@vonage/jwt");
const MediaMode_1 = require("./interfaces/MediaMode");
const ArchiveMode_1 = require("./interfaces/ArchiveMode");
const server_client_1 = require("@vonage/server-client");
class Video extends server_client_1.Client {
    authType = server_client_1.AuthenticationType.JWT;
    async addArchiveStream(archiveId, streamId, audio = true, video = true) {
        const data = {
            addStream: streamId,
            hasAudio: audio,
            hasVideo: video,
        };
        await this.sendPatchRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/archive/${archiveId}/stream`, data);
    }
    async addStreamToBroadcast(broadcastId, streamId) {
        await this.updateBroadcast({ broadcastId, addStream: streamId });
    }
    async connectToWebsocket(sessionId, clientToken, config) {
        const data = {
            sessionId,
            token: clientToken,
            websocket: config,
        };
        const resp = await this.sendPostRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/connect`, data);
        return resp.data;
    }
    async createSession(sessionOptions) {
        const data = {
            archiveMode: sessionOptions?.archiveMode ?? ArchiveMode_1.ArchiveMode.MANUAL,
            'p2p.preference': sessionOptions?.mediaMode ?? MediaMode_1.MediaMode.ROUTED,
            location: sessionOptions?.location ?? null,
        };
        const resp = await this.sendFormSubmitRequest(`${this.config.videoHost}/session/create`, data);
        return {
            sessionId: resp.data[0].session_id,
            archiveMode: data.archiveMode,
            mediaMode: data['p2p.preference'],
            location: data.location,
        };
    }
    async deleteArchive(archiveId) {
        await this.sendDeleteRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/archive/${archiveId}`);
    }
    async disableCaptions(captionId) {
        await this.sendPostRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/captions/${captionId}/stop`);
    }
    async disableForceMute(sessionId, excludedStreamIds = []) {
        return this.muteAllStreams(sessionId, false, excludedStreamIds);
    }
    async disconnectClient(sessionId, connectionId) {
        await this.sendDeleteRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/session/${sessionId}/connection/${connectionId}`);
    }
    async disconnectWebsocket(callId) {
        await this.sendPostRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/connect/${callId}/stop`);
    }
    async enableCaptions(sessionId, clientToken, captionOptions = {}) {
        const data = Object.assign({}, { sessionId, token: clientToken }, captionOptions);
        const resp = await this.sendPostRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/captions`, data);
        return resp.data;
    }
    async forceMuteAll(sessionId, excludedStreamIds = []) {
        return this.muteAllStreams(sessionId, true, excludedStreamIds);
    }
    generateClientToken(sessionId, tokenOptions) {
        const now = Math.round(new Date().getTime() / 1000);
        const claims = {
            scope: 'session.connect',
            session_id: sessionId,
            role: 'publisher',
            initial_layout_class_list: '',
            sub: 'video',
            acl: {
                paths: {
                    '/session/**': {},
                },
            },
        };
        if (tokenOptions?.role) {
            claims.role = tokenOptions.role;
        }
        if (tokenOptions?.data) {
            claims.connection_data = tokenOptions.data;
        }
        if (tokenOptions?.initialLayoutClassList) {
            claims.initial_layout_class_list
                = tokenOptions.initialLayoutClassList.join(' ');
        }
        if (tokenOptions?.expireTime && tokenOptions.expireTime > now) {
            claims.exp = tokenOptions.expireTime;
        }
        return (0, jwt_1.tokenGenerate)(this.auth.applicationId, this.auth.privateKey, claims);
    }
    async getArchive(archiveId) {
        const resp = await this.sendGetRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/archive/${archiveId}`);
        return resp.data;
    }
    async getBroadcast(broadcastId) {
        const resp = await this.sendGetRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/broadcast/${broadcastId}`);
        return resp.data;
    }
    async getCaptionStatus(captionId) {
        const resp = await this.sendGetRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/captions/${captionId}`);
        return resp.data;
    }
    async getExperienceComposerRender(renderId) {
        const resp = await this.sendGetRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/render/${renderId}`);
        return resp.data;
    }
    async getStreamInfo(sessionId, streamId) {
        let url = `${this.config.videoHost}/v2/project/${this.auth.applicationId}/session/${sessionId}/stream`;
        if (streamId) {
            url = url + `/${streamId}`;
        }
        let resp;
        if (streamId) {
            resp = await this.sendGetRequest(url);
        }
        else {
            resp = await this.sendGetRequest(url);
        }
        return resp.data;
    }
    stripBlankValues(obj) {
        for (const key in obj) {
            if (typeof obj[key] === 'object' && obj[key] !== null) {
                this.stripBlankValues(obj[key]);
            }
            else if (obj[key] === '') {
                delete obj[key];
            }
        }
        return obj;
    }
    async intiateSIPCall(sessionId, options) {
        let data = Object.assign({}, { sessionId }, options);
        const url = `${this.config.videoHost}/v2/project/${this.auth.applicationId}/dial`;
        // Fixes a bug found during integration
        // where blank values are treated differently than null values
        data = this.stripBlankValues(data);
        const resp = await this.sendPostRequest(url, data);
        return resp.data;
    }
    async listExperienceComposerRenders(filter) {
        const resp = await this.sendGetRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/render`, filter);
        return resp.data;
    }
    async muteAllStreams(sessionId, active, excludedStreamIds = []) {
        const resp = await this.sendPostRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/session/${sessionId}/mute`, {
            active,
            excludedStreamIds,
        });
        return resp.data;
    }
    async muteStream(sessionId, streamId) {
        const resp = await this.sendPostRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/session/${sessionId}/stream/${streamId}/mute`);
        return resp.data;
    }
    async playDTMF(sessionId, digits, connectionId) {
        let url = `${this.config.videoHost}/v2/project/${this.auth.applicationId}/session/${sessionId}/play-dtmf`;
        if (connectionId) {
            url = `${this.config.videoHost}/v2/project/${this.auth.applicationId}/session/${sessionId}/connection/${connectionId}/play-dtmf`;
        }
        await this.sendPostRequest(url, { digits });
    }
    async removeArchiveStream(archiveId, streamId) {
        await this.sendPatchRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/archive/${archiveId}/stream`, { removeStream: streamId });
    }
    async removeStreamFromBroadcast(broadcastId, streamId) {
        await this.updateBroadcast({ broadcastId, removeStream: streamId });
    }
    async searchArchives(filter) {
        const resp = await this.sendGetRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/archive`, filter);
        return resp.data;
    }
    async searchBroadcasts(filter) {
        const resp = await this.sendGetRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/broadcast/`, filter);
        return resp.data;
    }
    async sendSignal(signal, sessionId, connectionId) {
        let url = `${this.config.videoHost}/v2/project/${this.auth.applicationId}/session/${sessionId}/signal`;
        if (connectionId) {
            url = `${this.config.videoHost}/v2/project/${this.auth.applicationId}/session/${sessionId}/connection/${connectionId}/signal`;
        }
        await this.sendPostRequest(url, signal);
    }
    async setStreamClassLists(sessionId, settings) {
        await this.sendPutRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/session/${sessionId}/stream`, { items: settings });
    }
    async startArchive(sessionId, options) {
        const data = Object.assign({}, { sessionId }, options);
        const resp = await this.sendPostRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/archive`, data);
        return resp.data;
    }
    async startBroadcast(sessionId, config) {
        const data = Object.assign({}, { sessionId }, config);
        const resp = await this.sendPostRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/broadcast/`, data);
        return resp.data;
    }
    async startExperienceComposerRender(sessionId, token, config) {
        const data = Object.assign({}, { sessionId, token }, config);
        const resp = await this.sendPostRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/render`, data);
        return resp.data;
    }
    async stopArchive(archiveId) {
        const resp = await this.sendPostRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/archive/${archiveId}/stop`);
        return resp.data;
    }
    async stopBroadcast(broadcastId) {
        const resp = await this.sendPostRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/broadcast/${broadcastId}/stop`);
        return resp.data;
    }
    async stopExperienceComposerRender(renderId) {
        await this.sendDeleteRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/render/${renderId}`);
    }
    async updateArchiveLayout(archiveId, layout) {
        const resp = await this.sendPutRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/archive/${archiveId}/layout`, layout);
        return resp.data;
    }
    async updateBroadcast(config) {
        await this.sendPatchRequest(`${this.config.videoHost}/v2/project/${this.auth.applicationId}/broadcast/${config.broadcastId}/streams`, config);
    }
}
exports.Video = Video;
//# sourceMappingURL=video.js.map