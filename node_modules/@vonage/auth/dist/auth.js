"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Auth = void 0;
const jwt_1 = require("@vonage/jwt");
const crypto_1 = require("crypto");
const fs_1 = require("fs");
const enums_1 = require("./enums");
const index_1 = require("./errors/index");
const debug_1 = __importDefault(require("debug"));
const log = (0, debug_1.default)('vonage:auth');
class Auth {
    apiKey;
    apiSecret;
    privateKey;
    applicationId;
    signature;
    jwtOptions;
    constructor(opts) {
        this.apiKey = opts?.apiKey || '';
        this.apiSecret = opts?.apiSecret || '';
        this.signature = opts?.signature || null;
        this.applicationId = opts?.applicationId || null;
        this.jwtOptions = opts?.jwtOptions || {};
        if ((0, fs_1.existsSync)(opts.privateKey)) {
            log('Reading private key file');
            opts.privateKey = (0, fs_1.readFileSync)(opts.privateKey).toString();
        }
        this.privateKey
            = opts.privateKey instanceof Buffer
                ? opts.privateKey.toString()
                : opts.privateKey;
    }
    getQueryParams = async (params) => {
        if (!this.apiKey) {
            throw new index_1.MissingApiKeyError();
        }
        if (!this.apiSecret) {
            throw new index_1.MissingApiSecretError();
        }
        if (typeof this.apiKey !== 'string') {
            throw new index_1.InvalidApiKeyError();
        }
        if (typeof this.apiSecret !== 'string') {
            throw new index_1.InvalidApiSecretError();
        }
        return {
            ...params,
            api_key: this.apiKey,
            api_secret: this.apiSecret,
        };
    };
    createBasicHeader = async () => {
        log('Creating basic auth header');
        if (!this.apiKey) {
            throw new index_1.MissingApiKeyError();
        }
        if (!this.apiSecret) {
            throw new index_1.MissingApiSecretError();
        }
        if (typeof this.apiKey !== 'string') {
            throw new index_1.InvalidApiKeyError();
        }
        if (typeof this.apiSecret !== 'string') {
            throw new index_1.InvalidApiSecretError();
        }
        const buf = Buffer.from(`${this.apiKey}:${this.apiSecret}`);
        return `Basic ${buf.toString('base64')}`;
    };
    createBearerHeader = async () => {
        log('Creating bearer header');
        return `Bearer ${(0, jwt_1.tokenGenerate)(this.applicationId, this.privateKey, this.jwtOptions)}`;
    };
    createSignatureHash = async (params) => {
        log('Creating signature hash');
        if (!this.apiKey) {
            throw new index_1.MissingApiKeyError();
        }
        if (typeof this.apiKey !== 'string') {
            throw new index_1.InvalidApiKeyError();
        }
        if (!this.signature.algorithm) {
            throw new index_1.MissingSignatureError();
        }
        if (!this.signature.secret) {
            throw new index_1.MissingApiSecretError();
        }
        if (typeof this.signature.secret !== 'string') {
            throw new index_1.InvalidApiSecretError();
        }
        const returnParams = {
            ...params,
            api_key: this.apiKey,
        };
        // Add the current timestamp to the parameters list with the key
        // 'timestamp'. This should be an integer containing the number of seconds
        // since the epoch (UNIX time))
        if (!returnParams.timestamp) {
            returnParams.timestamp = Math.floor(Date.now() / 1000).toString();
        }
        const sortedParams = new URLSearchParams(returnParams);
        sortedParams.sort();
        const stringifiedParamsforSigning = sortedParams
            .toString()
            .replace(/(&|=)/gi, '_');
        switch (this.signature.algorithm) {
            case enums_1.AlgorithmTypes.md5hash:
                returnParams.sig = (0, crypto_1.createHash)('md5')
                    .update(`${stringifiedParamsforSigning}${this.signature.secret}`)
                    .digest('hex');
                break;
            case enums_1.AlgorithmTypes.md5hmac:
                returnParams.sig = (0, crypto_1.createHmac)('md5', this.signature.secret)
                    .update(stringifiedParamsforSigning)
                    .digest('hex');
                break;
            case enums_1.AlgorithmTypes.sha1hmac:
                returnParams.sig = (0, crypto_1.createHmac)('sha1', this.signature.secret)
                    .update(stringifiedParamsforSigning)
                    .digest('hex');
                break;
            case enums_1.AlgorithmTypes.sha256hmac:
                returnParams.sig = (0, crypto_1.createHmac)('sha256', this.signature.secret)
                    .update(stringifiedParamsforSigning)
                    .digest('hex');
                break;
            case enums_1.AlgorithmTypes.sha512hmac:
                returnParams.sig = (0, crypto_1.createHmac)('sha512', this.signature.secret)
                    .update(stringifiedParamsforSigning)
                    .digest('hex');
                break;
            default:
                throw new index_1.InvalidSignatureAlgorithmError();
        }
        return returnParams;
    };
}
exports.Auth = Auth;
//# sourceMappingURL=auth.js.map