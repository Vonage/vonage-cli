"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SMS = void 0;
const server_client_1 = require("@vonage/server-client");
const index_1 = require("./classes/index");
const index_2 = require("./enums/index");
const crypto_1 = __importDefault(require("crypto"));
const auth_1 = require("@vonage/auth");
class SMS extends server_client_1.Client {
    async send(params) {
        const resp = await this.sendPostRequest(`${this.config.restHost}/sms/json`, server_client_1.Client.transformers.kebabCaseObjectKeys(params));
        const messageData = server_client_1.Client.transformers.camelCaseObjectKeys(resp.data, true, true);
        const totalMessages = messageData.messageCount || 0;
        const messages = messageData.messages || [];
        const failures = messages.reduce((failures, { status }) => status !== index_2.SMSStatus.SUCCESS ? failures + 1 : failures, 0);
        if (failures < 1) {
            return messageData;
        }
        if (failures === totalMessages) {
            throw new index_1.MessageSendAllFailure(messageData);
        }
        throw new index_1.MessageSendPartialFailure(messageData);
    }
    verifySignature(signature, params, signatureSecret, algorithm) {
        params = params || {};
        let signedQuery = '';
        params = JSON.parse(JSON.stringify(params));
        if (params.sig) {
            delete params.sig;
        }
        Object.keys(params)
            .sort()
            .forEach((key) => {
            // replace & and = with _
            signedQuery += '&' + key + '=' + params[key].replace(/[&=]/g, '_');
        });
        const hashMap = {};
        hashMap[auth_1.AlgorithmTypes.md5hmac] = 'md5';
        hashMap[auth_1.AlgorithmTypes.sha1hmac] = 'sha1';
        hashMap[auth_1.AlgorithmTypes.sha256hmac] = 'sha256';
        hashMap[auth_1.AlgorithmTypes.sha512hmac] = 'sha512';
        let hash = '';
        switch (algorithm) {
            case auth_1.AlgorithmTypes.md5hash:
                signedQuery += signatureSecret;
                hash = crypto_1.default.createHash('md5').update(signedQuery).digest('hex');
                break;
            case auth_1.AlgorithmTypes.md5hmac:
            case auth_1.AlgorithmTypes.sha1hmac:
            case auth_1.AlgorithmTypes.sha256hmac:
            case auth_1.AlgorithmTypes.sha512hmac:
                hash = crypto_1.default
                    .createHmac(hashMap[algorithm], signatureSecret)
                    .update(signedQuery)
                    .digest('hex');
                break;
            default:
                throw new Error(`Unknown signature algorithm: ${algorithm}. Expected: md5hash, md5, sha1, sha256, or sha512`);
        }
        return signature.toUpperCase() === hash.toUpperCase();
    }
}
exports.SMS = SMS;
//# sourceMappingURL=sms.js.map